<?xml version="1.0"?>

<ruleset name="LuBanConcurrent" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
    <description>LuBanConcurrent</description>

    <rule name="DoubleCheckedLockingRule"
          language="java"
          message="（一）【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 "
          class="net.sourceforge.pmd.lang.java.rule.multithreading.DoubleCheckedLockingRule">
        <description>
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
           public class Foo {
    /*volatile */ Object baz = null; // fix for Java5 and later: volatile
    Object bar() {
        if (baz == null) { // baz may be non-null yet not fully created
            synchronized(this) {
                if (baz == null) {
                    baz = new Object();
                }
              }
        }
        return baz;
    }
}
                 ]]>
        </example>
    </rule>

<!--    <rule name="ThreadPoolCreationRule"-->
<!--          language="java"-->
<!--          since="1.6"-->
<!--          message="java.concurrent.ThreadPoolCreationRule.rule.msg"-->
<!--          class="com.xenoamess.p3c.pmd.lang.java.rule.concurrent.ThreadPoolCreationRule">-->
<!--        <description>java.concurrent.ThreadPoolCreationRule.rule.desc</description>-->
<!--        <priority>1</priority>-->
<!--        <example>-->
<!--            <![CDATA[-->
<!--Positive example 1：-->
<!--    //org.apache.commons.lang3.concurrent.BasicThreadFactory-->
<!--    ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,-->
<!--        new BasicThreadFactory.Builder().namingPattern("example-schedule-pool-%d").daemon(true).build());-->
<!--       ]]>-->
<!--        </example>-->
<!--        <example>-->
<!--            <![CDATA[-->
<!--Positive example 2：-->
<!--    ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()-->
<!--        .setNameFormat("demo-pool-%d").build();-->

<!--    //Common Thread Pool-->
<!--    ExecutorService pool = new ThreadPoolExecutor(5, 200,-->
<!--        0L, TimeUnit.MILLISECONDS,-->
<!--        new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());-->

<!--    pool.execute(()-> System.out.println(Thread.currentThread().getName()));-->
<!--    pool.shutdown();//gracefully shutdown-->
<!--       ]]>-->
<!--        </example>-->
<!--        <example>-->
<!--            <![CDATA[-->
<!--Positive example 3：-->
<!--    <bean id="userThreadPool"-->
<!--        class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">-->
<!--        <property name="corePoolSize" value="10" />-->
<!--        <property name="maxPoolSize" value="100" />-->
<!--        <property name="queueCapacity" value="2000" />-->

<!--    <property name="threadFactory" value= threadFactory />-->
<!--        <property name="rejectedExecutionHandler">-->
<!--            <ref local="rejectedExecutionHandler" />-->
<!--        </property>-->
<!--    </bean>-->
<!--    //in code-->
<!--    userThreadPool.execute(thread);-->
<!--       ]]>-->
<!--        </example>-->
<!--    </rule>-->

    <rule name="AvoidCreateThreadRule"
          language="java"
          message="（三）【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 "
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule">
        <description>
            （三）【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ConstructorCall[pmd-java:typeIsExactly('java.lang.Thread')]
]]>
                </value>
            </property>
        </properties>
    </rule>
</ruleset>
