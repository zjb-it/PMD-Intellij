<?xml version="1.0"?>

<ruleset name="LuBanConcurrent" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">
    <description>LuBanConcurrent</description>

    <rule name="DoubleCheckedLockingRule"
          language="java"
          message="（一）【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 "
          class="net.sourceforge.pmd.lang.java.rule.multithreading.DoubleCheckedLockingRule">
        <description>
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
           public class Foo {
    /*volatile */ Object baz = null; // fix for Java5 and later: volatile
    Object bar() {
        if (baz == null) { // baz may be non-null yet not fully created
            synchronized(this) {
                if (baz == null) {
                    baz = new Object();
                }
              }
        }
        return baz;
    }
}
                 ]]>
        </example>
    </rule>

    <rule name="ThreadPoolCreationRule"
          language="java"
          since="1.6"
          message=""
          class="com.intellij.plugins.bodhi.pmd.lang.java.rule.concurrent.ThreadPoolCreationRule">
        <description>
            说明：Executors 返回的线程池对象的弊端如下：
            1. FixedThreadPool 和 SingleThreadPool：
            允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
            2. CachedThreadPool：
            允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM
        </description>
        <priority>1</priority>
        <example>
            <![CDATA[
示例 1：
    //org.apache.commons.lang3.concurrent.BasicThreadFactory
    ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,
        new BasicThreadFactory.Builder().namingPattern("example-schedule-pool-%d").daemon(true).build());
       ]]>
        </example>
        <example>
            <![CDATA[
示例 2：
    ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
        .setNameFormat("demo-pool-%d").build();

    //Common Thread Pool
    ExecutorService pool = new ThreadPoolExecutor(5, 200,
        0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());

    pool.execute(()-> System.out.println(Thread.currentThread().getName()));
    pool.shutdown();//gracefully shutdown
       ]]>
        </example>
        <example>
            <![CDATA[
示例 3：
    <bean id="userThreadPool"
        class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
        <property name="corePoolSize" value="10" />
        <property name="maxPoolSize" value="100" />
        <property name="queueCapacity" value="2000" />

    <property name="threadFactory" value= threadFactory />
        <property name="rejectedExecutionHandler">
            <ref local="rejectedExecutionHandler" />
        </property>
    </bean>
    //in code
    userThreadPool.execute(thread);
       ]]>
        </example>
    </rule>

    <rule name="AvoidCreateThreadRule"
          language="java"
          message="（三）【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 "
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule">
        <description>
            （三）【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ConstructorCall[pmd-java:typeIsExactly('java.lang.Thread')]
]]>
                </value>
            </property>
        </properties>
    </rule>

    <rule name="LockShouldWithTryFinallyRule"
          language="java"
          message="（八）【强制】在使用阻塞等待获取锁的方式中必须在 try 代码块之外，并且在加锁方法与 try代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule">
        <description>
            说明一：如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。
            说明二：如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock 对未加锁的对象解锁，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），抛出 IllegalMonitorStateException 异常。
            说明三：在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ExpressionStatement[MethodCall[pmd-java:matchesSig("java.util.concurrent.locks.Lock#lock()")]]
[not(./following-sibling::*//FinallyClause//MethodCall[pmd-java:matchesSig("java.util.concurrent.locks.Lock#unlock()")])]

]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
正例：
    Lock lock = new XxxLock();
    // ...
    lock.lock();
    try {
        doSomething();
        doOthers();
    } finally {
        lock.unlock();
    }
        ]]>
        </example>
        <example>
            <![CDATA[
反例：
    Lock lock = new XxxLock();
    // ...
    try {
        // 如果异常，lock还未加锁，进入finally中 unlock会异常IllegalMonitorStateException
        doSomething();
        // 如果加锁未成功异常，进入finally中 unlock会异常IllegalMonitorStateException
        lock.lock();
        doOthers();

    } finally {
        lock.unlock();
    }
        ]]>
        </example>
    </rule>



</ruleset>
